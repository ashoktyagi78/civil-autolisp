# Engineering Cheatsheet

## Commands
This is current loaded routines:
```lisp
(defun c:1() (princ "\nBY: ") (c:BY))
(defun c:2() (princ "\nINT: ") (c:INT))
(defun c:3() (princ "\nSDIPforPrivateSewers: ") (c:SDIPforPrivateSewers))
(defun c:33() (princ "\nSDIP: ") (c:SDIP))
(defun c:pa()(fbi "Parking-Fall-Arrow") (vlax-put-property (vlax-ename->vla-object (entlast)) 'Layer "e-road-fall-arrow") )
(defun c:ra()(fbi "Road-Fall-Arrow") (vlax-put-property (vlax-ename->vla-object (entlast)) 'Layer "e-road-fall-arrow") )
(defun c:rr()(c:RTM))
(defun c:os()(setvar "osmode" 4))
(defun c:ne()(setvar "osmode" 512))
(defun c:11 ( / targetLevel ent_name )
  ; Get a FFL, substract -0.65m and overwrite the target text object content
  ; with the calculated value properly formated: S16.70
  (princ "\nGET STORM LEVEL FROM FFL\n")
  (setq
    targetLevel (+ (DT:clic_or_type_level) -0.65)
    ent_name (car (entsel (strcat "\nSelect text to overwrite with \"S" (LM:rtos targetLevel 2 2) "\": ") ))
  )
  (if ent_name
    (vlax-put-property (vlax-ename->vla-object ent_name) 'TextString (strcat "S" (LM:rtos targetLevel 2 2)) )
    (princ "\nNo target entity selected.")
  );END if
  (princ)
)
(defun c:22 ( / targetLevel ent_name )
  ; Get a FFL, substract -0.75m and overwrite the target text object content
  ; with the calculated value properly formated: F16.70
  (princ "\nGET FOUL LEVEL FROM FFL\n")
  (setq
    targetLevel (+ (DT:clic_or_type_level) -0.75)
    ent_name (car (entsel (strcat "\nSelect text to overwrite with \"F" (LM:rtos targetLevel 2 2) "\": ") ))
  )
  (if ent_name
    (vlax-put-property (vlax-ename->vla-object ent_name) 'TextString (strcat "F" (LM:rtos targetLevel 2 2)) )
    (princ "\nNo target entity selected.")
  );END if
  (princ)
)
```

## Command usage

La idea es utilizar el 11 y el 22 para calcular el max level desde los FFL para storm y foul respectivamente.
El 1 es para poner ByLayer
El 2, 3 y 33 para calculos:
 * 2 interpolar
 * 3 para SDIP que redondea a .05, inserta el valor en el texto de la arqueta de destino y copia en el portapapeles el gradient real tras redondear.
 * 33 SDIP standard que inserta bloque
para resetear el OSNAP os (OSMODE=4)
para rotar y mover, el rr=RTM
para insertar las parking arrows: pa

## Posible improvements

con el c:3 insertar el gradiente en el texto del tirón en vez de copiarlo en el clipboard
con el c:3 dejar gripadas (seleccionadas) los textos modificados par que si quieres ponerlos ByLayes solo tengas que hacer c:1.


# Engineering process

Se supone que la drainage strategy está ya hecha (pipes sketched on plan). Así es como lo hace Wayne:

  1. Obtener los Cover Levels:
    1. Obtener 3dpolys para las centerline.
    2. Hacer 3Doffsets según sea camber o crossfall (no hace falta que sea hasta la channel line, con que cubra la arqueta basta)
    3. Trimear las 3dpolys en las intersecciones para que la triangulación sea correcta, pero no hagas 3Djunctions, solo que cubra las arquetas...
    4. Generar un 3Dmodel temporal
    5. Interpolar con KTF los puntos en el centro de cada arqueta para obtener los niveles
    6. Meter los CL en las arquetas
  2. Dar nombre a todas las arquetas con el criterio de MicroDrainage: empezar por el punto más alto de las ramas, y cuando llegas al punto donde se unen las ramas, no etiquetar la arqueta, sino que continuas por el punto más alto de la otra rama que vierte a la arqueta no vas a numerar. Solo se numbera la arqueta donde se unen las ramas cuando todas las ramas que vierten a esa arqueta ya están numeradas.
  3. Empezar a dar niveles por los puntos más altos de las ramas, manteniéndote siempre 1.25m por debajo de la superficie de la carretera (para eso querías los Cover Level) o más abajo si la pendiente del drenaje así lo marca.

Y listo.
Con esto ya se le puede pasar el diseño al departamento de drenajes para que lo metan a MicroDrainage y te digan los tamaños de tubería.
